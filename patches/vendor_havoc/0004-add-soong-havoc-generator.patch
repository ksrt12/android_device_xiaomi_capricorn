From 5829e1d2fff7de29f7390a4ba56e9352e5a363fc Mon Sep 17 00:00:00 2001
From: Kazakov Stepan <kazakov12stepan2012@live.ru>
Date: Wed, 31 Oct 2018 16:54:56 +0300
Subject: [PATCH 4/6] add soong-havoc-generator

Signed-off-by: Kazakov Stepan <ksrt12group@gmail.com>
---
 build/soong/Android.bp             |  38 ++++
 build/soong/generator/generator.go | 310 +++++++++++++++++++++++++++++
 build/soong/generator/variables.go |  28 +++
 3 files changed, 376 insertions(+)
 create mode 100644 build/soong/generator/generator.go
 create mode 100644 build/soong/generator/variables.go

diff --git a/build/soong/Android.bp b/build/soong/Android.bp
index b9a8cd94..d2482fc0 100644
--- a/build/soong/Android.bp
+++ b/build/soong/Android.bp
@@ -5,3 +5,41 @@ bootstrap_go_package {
         "android/variable.go",
     ],
 }
+
+bootstrap_go_package {
+    name: "soong-havoc-generator",
+    pkgPath: "havoc/soong/generator",
+    deps: [
+        "blueprint",
+        "blueprint-pathtools",
+        "soong",
+        "soong-android",
+        "soong-shared",
+    ],
+    srcs: [
+        "generator/generator.go",
+        "generator/variables.go",
+    ],
+    pluginFor: ["soong_build"],
+}
+
+havoc_generator {
+    name: "generated_kernel_includes",
+
+    // The headers make command
+    cmd: "make $(KERNEL_MAKE_FLAGS) -C $(TARGET_KERNEL_SOURCE) O=$(genDir) ARCH=$(KERNEL_ARCH) $(KERNEL_CROSS_COMPILE) $(KERNEL_CLANG_TRIPLE) $(KERNEL_CC) headers_install",
+
+    // Directories that can be imported by a cc_* module generated_headers property
+    export_include_dirs: ["usr/include"],
+
+    // Sources for dependency tracking
+    dep_root: "kernel/xiaomi/msm8996",
+    dep_files: [ "Makefile", "include/**/*", "arch/$(KERNEL_ARCH)/include/**/*"],
+}
+
+cc_library_headers {
+    name: "generated_kernel_headers",
+    generated_headers: ["generated_kernel_includes"],
+    export_generated_headers: ["generated_kernel_includes"],
+    vendor_available: true,
+}
diff --git a/build/soong/generator/generator.go b/build/soong/generator/generator.go
new file mode 100644
index 00000000..43dc574d
--- /dev/null
+++ b/build/soong/generator/generator.go
@@ -0,0 +1,310 @@
+// Copyright 2015 Google Inc. All rights reserved.
+// Copyright (C) 2018 The LineageOS Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package generator
+
+import (
+	"fmt"
+	"strings"
+
+	"github.com/google/blueprint"
+	"github.com/google/blueprint/bootstrap"
+	"github.com/google/blueprint/proptools"
+
+	"android/soong/android"
+	"android/soong/shared"
+	"path/filepath"
+)
+
+func init() {
+	android.RegisterModuleType("havoc_generator", GeneratorFactory)
+
+	pctx.HostBinToolVariable("sboxCmd", "sbox")
+}
+
+var String = proptools.String
+
+var (
+	pctx = android.NewPackageContext("android/soong/generator")
+)
+
+type HostToolProvider interface {
+	HostToolPath() android.OptionalPath
+}
+
+type hostToolDependencyTag struct {
+	blueprint.BaseDependencyTag
+}
+
+var hostToolDepTag hostToolDependencyTag
+
+type generatorProperties struct {
+	// The command to run on one or more input files. Cmd supports substitution of a few variables
+	// (the actual substitution is implemented in GenerateAndroidBuildActions below)
+	//
+	// Available variables for substitution:
+	//
+	//  $(location): the path to the first entry in tools or tool_files
+	//  $(location <label>): the path to the tool or tool_file with name <label>
+	//  $(genDir): the sandbox directory for this tool; contains $(out)
+	//  $$: a literal $
+	//
+	Cmd *string
+
+	// name of the modules (if any) that produces the host executable.   Leave empty for
+	// prebuilts or scripts that do not need a module to build them.
+	Tools []string
+
+	// Local file that is used as the tool
+	Tool_files []string
+
+	// List of directories to export as headers
+	Export_include_dirs []string
+
+	// List of directories to export as sources
+	Export_source_dirs []string
+
+	// Root directory for dep_files.
+	// Relative to top build dir.
+	Dep_root *string
+
+	// Declare list of files that should be used for timestamp dependency checking
+	Dep_files []string
+}
+
+type Module struct {
+	android.ModuleBase
+
+	properties generatorProperties
+
+	rule blueprint.Rule
+
+	// Tool dependencies
+	implicitDeps android.Paths
+	// Deps from input files declared in dep_files property.
+	inputDeps android.Paths
+
+	exportedIncludeDirs android.Paths
+	exportedSourceDirs  android.Paths
+
+	outputDeps android.Paths
+}
+
+// These three methods satisfy genrule.SourceFileGenerator.
+// Which cc modules check for when including headers etc.
+func (g *Module) GeneratedHeaderDirs() android.Paths {
+	return g.exportedIncludeDirs
+}
+
+func (g *Module) GeneratedSourceFiles() android.Paths {
+	return g.exportedSourceDirs
+}
+
+func (g *Module) GeneratedDeps() android.Paths {
+	return g.outputDeps
+}
+
+func (g *Module) DepsMutator(ctx android.BottomUpMutatorContext) {
+	android.ExtractSourcesDeps(ctx, g.properties.Dep_files)
+	android.ExtractSourcesDeps(ctx, g.properties.Tool_files)
+	if g, ok := ctx.Module().(*Module); ok {
+		if len(g.properties.Tools) > 0 {
+			ctx.AddFarVariationDependencies([]blueprint.Variation{
+				{"arch", ctx.Config().BuildOsVariant},
+			}, hostToolDepTag, g.properties.Tools...)
+		}
+	}
+}
+
+func (g *Module) GenerateAndroidBuildActions(ctx android.ModuleContext) {
+	if len(g.properties.Export_include_dirs) > 0 {
+		for _, dir := range g.properties.Export_include_dirs {
+			g.exportedIncludeDirs = append(g.exportedIncludeDirs,
+				android.PathForModuleGen(ctx, dir))
+		}
+	} else {
+		g.exportedIncludeDirs = append(g.exportedIncludeDirs, android.PathForModuleGen(ctx, ""))
+	}
+	if len(g.properties.Export_source_dirs) > 0 {
+		for _, dir := range g.properties.Export_source_dirs {
+			g.exportedSourceDirs = append(g.exportedSourceDirs,
+				android.PathForModuleGen(ctx, dir))
+		}
+	} else {
+		g.exportedSourceDirs = append(g.exportedSourceDirs, android.PathForModuleGen(ctx, ""))
+	}
+
+	tools := map[string]android.Path{}
+
+	if len(g.properties.Tools) > 0 {
+		ctx.VisitDirectDepsBlueprint(func(module blueprint.Module) {
+			switch ctx.OtherModuleDependencyTag(module) {
+			case android.SourceDepTag:
+				// Nothing to do
+			case hostToolDepTag:
+				tool := ctx.OtherModuleName(module)
+				var path android.OptionalPath
+
+				if t, ok := module.(HostToolProvider); ok {
+					if !t.(android.Module).Enabled() {
+						if ctx.Config().AllowMissingDependencies() {
+							ctx.AddMissingDependencies([]string{tool})
+						} else {
+							ctx.ModuleErrorf("depends on disabled module %q", tool)
+						}
+						break
+					}
+					path = t.HostToolPath()
+				} else if t, ok := module.(bootstrap.GoBinaryTool); ok {
+					if s, err := filepath.Rel(android.PathForOutput(ctx).String(), t.InstallPath()); err == nil {
+						path = android.OptionalPathForPath(android.PathForOutput(ctx, s))
+					} else {
+						ctx.ModuleErrorf("cannot find path for %q: %v", tool, err)
+						break
+					}
+				} else {
+					ctx.ModuleErrorf("%q is not a host tool provider", tool)
+					break
+				}
+
+				if path.Valid() {
+					g.implicitDeps = append(g.implicitDeps, path.Path())
+					if _, exists := tools[tool]; !exists {
+						tools[tool] = path.Path()
+					} else {
+						ctx.ModuleErrorf("multiple tools for %q, %q and %q", tool, tools[tool], path.Path().String())
+					}
+				} else {
+					ctx.ModuleErrorf("host tool %q missing output file", tool)
+				}
+			default:
+				ctx.ModuleErrorf("unknown dependency on %q", ctx.OtherModuleName(module))
+			}
+		})
+	}
+
+	if ctx.Failed() {
+		return
+	}
+
+	toolFiles := ctx.ExpandSources(g.properties.Tool_files, nil)
+	for _, tool := range toolFiles {
+		g.implicitDeps = append(g.implicitDeps, tool)
+		if _, exists := tools[tool.Rel()]; !exists {
+			tools[tool.Rel()] = tool
+		} else {
+			ctx.ModuleErrorf("multiple tools for %q, %q and %q", tool, tools[tool.Rel()], tool.Rel())
+		}
+	}
+
+	// Determine root dir for dep_files.  Defaults to current ctx ModuleDir.
+	depRoot := String(g.properties.Dep_root)
+	if depRoot == "" {
+		depRoot = ctx.ModuleDir()
+	} else {
+		depRoot = havocExpandVariables(ctx, depRoot)
+	}
+
+	// Glob dep_files property
+	for _, dep_file := range g.properties.Dep_files {
+		dep_file = havocExpandVariables(ctx, dep_file)
+		globPath := filepath.Join(depRoot, dep_file)
+		paths, err := ctx.GlobWithDeps(globPath, nil)
+		if err != nil {
+			ctx.ModuleErrorf("unable to glob %s: %s", globPath, err.Error())
+			return
+		}
+		for _, path := range paths {
+			g.inputDeps = append(g.inputDeps, android.PathForSourceRelaxed(ctx, path))
+		}
+	}
+
+	cmd := havocExpandVariables(ctx, String(g.properties.Cmd))
+
+	rawCommand, err := android.Expand(cmd, func(name string) (string, error) {
+		switch name {
+		case "location":
+			if len(g.properties.Tools) == 0 && len(toolFiles) == 0 {
+				return "", fmt.Errorf("at least one `tools` or `tool_files` is required if $(location) is used")
+			}
+
+			if len(g.properties.Tools) > 0 {
+				return tools[g.properties.Tools[0]].String(), nil
+			} else {
+				return tools[toolFiles[0].Rel()].String(), nil
+			}
+		case "genDir":
+			return "__SBOX_OUT_DIR__", nil
+		default:
+			if strings.HasPrefix(name, "location ") {
+				label := strings.TrimSpace(strings.TrimPrefix(name, "location "))
+				if tool, ok := tools[label]; ok {
+					return tool.String(), nil
+				} else {
+					return "", fmt.Errorf("unknown location label %q", label)
+				}
+			}
+			return "", fmt.Errorf("unknown variable '$(%s)'", name)
+		}
+	})
+
+	if err != nil {
+		ctx.PropertyErrorf("cmd", "%s", err.Error())
+		return
+	}
+
+	// Dummy output dep
+	dummyDep := android.PathForModuleGen(ctx, ".dummy_dep")
+
+	// tell the sbox command which directory to use as its sandbox root
+	buildDir := android.PathForOutput(ctx).String()
+	sandboxPath := shared.TempDirForOutDir(buildDir)
+
+	genDir := android.PathForModuleGen(ctx)
+	// Escape the command for the shell
+	rawCommand = "'" + strings.Replace(rawCommand, "'", `'\''`, -1) + "'"
+	sandboxCommand := fmt.Sprintf("$sboxCmd --sandbox-path %s --output-root %s --copy-all-output -c %s && touch %s",
+		sandboxPath, genDir, rawCommand, dummyDep.String())
+
+	ruleParams := blueprint.RuleParams{
+		Command:     sandboxCommand,
+		CommandDeps: []string{"$sboxCmd"},
+	}
+	g.rule = ctx.Rule(pctx, "generator", ruleParams)
+
+	params := android.BuildParams{
+		Rule:        g.rule,
+		Description: "generate",
+		Output:      dummyDep,
+		Inputs:      g.inputDeps,
+		Implicits:   g.implicitDeps,
+	}
+
+	g.outputDeps = append(g.outputDeps, dummyDep)
+
+	ctx.Build(pctx, params)
+}
+
+func NewGenerator() *Module {
+	module := &Module{}
+	module.AddProperties(&module.properties)
+	return module
+}
+
+func GeneratorFactory() android.Module {
+	m := NewGenerator()
+	android.InitAndroidModule(m)
+	return m
+}
diff --git a/build/soong/generator/variables.go b/build/soong/generator/variables.go
new file mode 100644
index 00000000..cd3c04e6
--- /dev/null
+++ b/build/soong/generator/variables.go
@@ -0,0 +1,28 @@
+package generator
+
+import (
+	"fmt"
+
+	"android/soong/android"
+)
+
+func havocExpandVariables(ctx android.ModuleContext, in string) string {
+	havocVars := ctx.Config().VendorConfig("havocVarsPlugin")
+
+	out, err := android.Expand(in, func(name string) (string, error) {
+		if havocVars.IsSet(name) {
+			return havocVars.String(name), nil
+		}
+		// This variable is not for us, restore what the original
+		// variable string will have looked like for an Expand
+		// that comes later.
+		return fmt.Sprintf("$(%s)", name), nil
+	})
+
+	if err != nil {
+		ctx.PropertyErrorf("%s: %s", in, err.Error())
+		return ""
+	}
+
+	return out
+}
-- 
2.19.1

